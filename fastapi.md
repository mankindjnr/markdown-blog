# API DEVELOPMENT WITH FASTAPI

## INSTALLATION
```bash
pip install fastapi[all]
```
With the all option, you will install even the optional dependancies that you may or may not need.

## Introduction
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}
```
__app__ is an instance of the class FastAPI. It is the main object of our application. It is the instance of the class that FastAPI() returns.

__async def root()__ this is normal python function, the async keyword is not mandatory and is used if you are going to make asynchronous calls inside the function, like querying a database or making an API call.

removing the async keyword will not affect the functionality of the function.

__@app.get("/")__ this is a decorator, it is used to add functionality to the function. In this case, it is used to add the path to the function. The path is the URL that will be used to access the function.

### starting the server
```bash
uvicorn main:app --reload
```
__--reload__ will only be needed on the development server.

__ORDER MATTERS__

When you run an endpoint, fastapi goes through all the function from top down and picks the first path that matches your request. If you have two paths that match then the server will pick the first one and run with it.

### TESTING
To test the application we will use postman. Postman is a tool that allows us to make API calls to our server.
We can also use the __/docs__ or __/redoc__ endpoint to test our application. This endpoint is automatically generated by fastapi and it allows us to test our application.

When the api development is complete, we can create a frontend application that will consume the API. A pyhon client of some sort, This application will make __requests__ to the server and the server will respond with the __response__.


## POST REQUESTS
With a post request, we can send data to the server.

```python
from fastapi.params import Body
@app.post("/createpost")
def create_post(payload: dict = Body(...)):
    print(payload)
    return {"message": "Post created"}

```
__Body__ is a class that is used to get the body of the request. It is provided by __fastapi.params__. It contains the data sent to the server. 
In our snippet above __Body(...)__ is used to tell fastapi that the body is required. If we don't want the body to be required, we can use __Body(None)__. This will tell fastapi that the body is optional.
__Body(...)__ takes the data that's is sent and converts it to a python dictionary and stores it in the variable __payload__. __dict__ in our context above is a type hint. It tells fastapi that the data sent to the server is a dictionary.

You can then retrieve the data stored in the payload and store it in the database.


## SCHEMA
We want to force the user at the frontend to enter data explicitly in a way we have defined. We can do this by creating a schema.

With fastApi we will use a tool called __pydantic__ to create a schema. But pydantic is not limited to fastapi, it can be used with other frameworks.


```python
from pydantic import BaseModel

class Post(BaseModel):
    title: str
    content: str

@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    return {"message": "Post created successfully"}
```
__BaseModel__ is a class that is provided by pydantic. It is used to create a schema.
__create_post(new_post: Post)__ the new_post variable is an instance of the class Post. It is the data that is sent to the server. The data is then validated against the schema. If the data is valid, it is stored in the database. If the data is invalid, an error is returned.

With the schema defined, if we send data that does not comply, validation happens authomatically and we will we receive an error message. It also tries to convert the data to the type we have defined. If it fails, an error is returned.

To access a single value of the body sent we can __new_post.title__ or __new_post.content__.

### OPTIONAL FIELDS
```python
from typing import Optional

class Post(BaseModel):
    title: str
    content: str
    published: bool = False
    rating: Optiona[int] = None
```

Here we have an optional field __published__. It is optional because it has a default value that is assigned to it it the user does not assign one by default. We could assign it a value of True/False if we wanted to. We could use that value in the database to determine if the post is published or not.

To have a completely optional field, we can use __Optional__ from __typing__.
__rating__ is fully optional and hwhen not provided, it will be assigned a value of None.

The pydantic object has a method__dict()__ which converts it to a python dictionary.

```python
@app.post("/createpost")
def create_post(new_post: Post):
    print(new_post)
    print(new_post.dict())
    return {"message": "Post created successfully"}
```

## CRUD OPERATIONS

### creating and retrieving
STORING IN MEMORY
```python
my_posts = []

# creating a single post to memory - the array above
@app.post("/posts")
def create_post(post: Post):
    post_dict = post.dict()
    post_dict["id"] = randint(0, 1000000)
    my_posts.append(post_dict)
    return {"data": post_dict}

"""
with the code above, the default status code on success is 200, if we want to change it, we can do so by adding the status_code parameter to the function. We will add a status code that rerpresents success in creating a resource. We will use 201.
"""
@app.post("/posts", status_code=status.HTTP_201_CREATED)

# getting a single post from memory- the list above
def get_post_from_database(id: int):
    for post in my_posts:
        if post["id"] == id:
            return post

# retrieving the latest post
# We are bringing this section above the retrieval with id because they may collide
@app.get("/posts/latest")
def get_latest_post():
    return {"data": my_posts[-1]}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        response.status_code = status.HTTP_404_NOT_FOUND
        return {"detail": f"Post with id {id} not found"}
    return {"data": post}

@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

### DELETING
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    post = get_post_from_database(id)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    my_posts.remove(post) # you could use the pop method
    return {"data": "Post deleted"}
```

### UPDATING
For updating, two methods are provided, PUT AND PATCH.
__PUT__ is used to update the entire resource. Even when you are updating a single element, you have to send the entire resource.

__PATCH__ is used to update a single element of the resource. It is used when you don't want to send the entire resource.

```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    current = get_post_from_database(id)

    if not current:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")
    post_dict = post.dict()
    post_dict["id"] = id
    my_posts[id] = post_dict
    return {"data": post_dict}
```

## STRUCTURE
we currently have our working files in the base directory. We will create a folder called __app__ and move all our files there. We will also create a file called **__init__.py** in the base directory. This file will that folder to a python package.

Now with this new structure, to run our application using uvicorn, the command will change to:
```bash
uvicorn app.main:app --reload
```
__app__ is the name of the folder, __main__ is the name of the file and __app__ is the name of the instance of the class FastAPI.

***
***
# DATABASE
We don't interact with the database directly, instead we use a database management system. It sits in the middle between our application and the database. It is responsible for managing the database. It is also responsible for translating the data from the database to the application and vice versa.

We are going to use postgres as our database
### POSTGRES
Each instance of postgres can be carved into multiple separate databases. They can be operated separately.
install postgres and the pgAdmin to have a graphical user interface to manage the database.

in postgres when you insert items and want them to be returned back to you, you use the __returning__ keyword.
This will be useful when buidling our API since we want to send back the data that was inserted into the database.
```sql
INSERT INTO products (name, price, inventory) VALUES ('drves', 44, 1523) returning *;
```

while deleting items and want to see teh item you are deleting as it gets deleted, you could use the __return__ keyword.
```sql
DELETE FROM products where id = 11 RETURNING *;
```
***
***
### accessing the postgres db from our python file
```python
while True:
    try:
        conn = psycopg2.connect(host='localhost', database='fastapi', user='postgres', password='', cursor_factory=RealDictCursor)
        cursor = conn.cursor()
        print("DATABSE CONN IS A SUCCESS")
        break
    except Exception as error:
        print("DATABSE CONN IS A FAILURE", error)
        time.sleep(2)
```

In the code above we use a while loop to keep trying to connect if the connection fails.

__cursor_factory=RealDictCursor__ is used to return the data as a dictionary. This will be useful when we are returning the data to the user.

***
***
### retrieving all data from the database
```python
@app.get("/posts")
def get_posts():
    cursor.execute("SELECT * FROM posts")
    my_posts = cursor.fetchall()
    return {"data": my_posts}
```

***
***
### retrieving a single item from the database
```python
@app.get("/posts/{id}")
def get_post(id: int, response: Response):
    cursor.execute("SELECT * FROM posts WHERE id = %s", (id,))
    post = cursor.fetchone()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"data": post}
```

__(id,)__ is a tuple. It is used to pass the id to the query. It is used to prevent sql injection.
We can also try __str(id),__ but it is not recommended since it is prone to sql injection.

***
***
### inserting data into the database
```python
cursor.execute("INSERT INTO posts (title, content, published) VALUES (%s, %s, %s) RETURNING *", (post.title, post.content, post.published))

new_post = cursor.fetchone()
conn.commit()
return {"data": new_post}
```

This way of inserting sanitizes the input hence preventing sql injection.
__RETURNING *__ is used to return the data that was inserted into the database.
__new_post = cursor.fetchone()__ is used to get the data that was inserted into the database.
__conn.commit()__ is used to commit the changes to the database. it pushes the changes to the database.

***
***

### DELETING DATA FROM THE DATABASE
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int):
    cursor.execute("DELETE FROM posts WHERE id = %s returning *", (id,))
    deleted_post = cursor.fetchone()
    conn.commit()

    if not deleted_post:
        raise HTTPException(status_code=404, detail="Post not found")

    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

***
***

### UPDATING DATA IN THE DATABASE
```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post):
    cursor.execute("UPDATE posts SET title = %s, content = %s, published = %s WHERE id = %s RETURNING *", (post.title, post.content, post.published, id))
    
    updated_post = cursor.fetchone()
    conn.commit()

    if not updated_post:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")

    return {"data": updated_post}
```

***
***

## OBJECT RELATIONAL MAPPER (ORM)
ORM is a library that allows us to interact with the database using python objects. It allows us to interact with the database without writing sql queries.

## SQLALCHEMY

### INSTALLATION
```bash
pip install SQLAlchemy==1.4
```
sqlalchemy does not know how to talk to databases, it needs a database driver, the driver is determined by the database you choose, for us, we are using __postgres__ hence our driver is __psycopg2__.

```bash
pip install psycopg2-binary
```

The __fastApi__ documentation provides a way to integrate sqlalchemy with fastapi under the __ORM__ section.

### Connecting to the database

the format of the connection string and the engine:

```database.py``
```python
sqlalchemy_url = 'postgresql://<username>:<password>@<ip-address/hostname>/<database-name>'
sqlalchemy_url = 'postgresql://postgres:mankindjnr@127.0.0.1/fastapi'

engine = create_engine(sqlalchemy_url)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
```

Wit orms we no longer have to create tables with the pgadmin or the like, we can declare those tables using python models.

***

```models.py```

```python
from .database import Base
from sqlalchemy import Column, Integer, String, Text, DateTime
import datetime

class Post(Base):
    __tablename__ = 'posts'

    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(String(255), nullable=False)
    content = Column(String, nullable=False)
    published = Column(Boolean, default=True, nullable=False)
    created = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))
```

__Base__ is the base class that is provided by sqlalchemy. It is used to create the tables in the database.
__Column(String(255))__ the string constraint is used for fields that do not expect large input while __Text__ is used for fields that expect large input, i.e. blog posts, articles. Use __Text__ when there is no limit to the number of characters that can be entered. __String__ when you want to limit the number of characters that can be entered. __String(255)__ means that the field can only take 255 characters.

```update to main.py```
```python
from . import models
from .database import engine, SessionLocal

models.Base.metadata.create_all(bind=engine)

app = FastAPI()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### testing if our connection worked
```python
@app.get("/sqlalchemy")
def test(db: Session = Depends(get_db)):
    return {"message": "Hello orm"}
```

When we run the code, the models we defined are checked if those tables exist in the database, if not, they are created, if they exist, nothing happens.

***
sqlalchemy does not handle databse changes, when you update a table and it already existed, those changes will not reflect in the database, to make those changes stick, we use another tool to __migrate__ our changes. The tool is __alembic__.

### testing
```python
@app.get("/sqlalchemy")
def test(db: Session = Depends(get_db)):
    posts = db.query(models.Post).all()
    return {"data": posts}
```
While working with sqlalchemy you need to call the connection to the database __db__.
hence
```python
db.query(models.Post).all()
```
the query __db.query(models.Post)__ is used to query the database and the __.all()__ is used to get all the data from the database and execute the query.

***
***

### retrieving all items with orm
```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: Post, db: Session = Depends(get_db)):
    new_post = models.Post(title=post.title, content=post.content, published=post.published)
    return {"data": new_post}
```

***
***

### creating a single item with orm
```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: Post, db: Session = Depends(get_db)):
    new_post = models.Post(title=post.title, content=post.content, published=post.published)

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return {"data": new_post}
```

We create the post and store it in the variable new_post
we then add the new post to the database
we then commit the changes to the database(saving them)
we then retrieve that post (__equivalent of return in raw sql__) using refresh adn store it in variable __new_post__
we then return the new_post

The above way of mapping items to the columsn will prove inefficient when our models grow, to solve that we can unpack the pydantic model using the __.dict()__ method.

```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: Post, db: Session = Depends(get_db)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return {"data": new_post}
```

Now, it will not matter how many fields our models have, all the fields described in our pydantic model will be mapped to the columns in our database.

***
***

### retrieving a single item with orm
```python
@app.get("/posts/{id}")
def get_post(id: int, db: Session = Depends(get_db)):
    post = db.query(models.Post).filter(models.Post.id == id).first()

    if not post:
        raise HTTPException(status_code=404, detail=f"Post of id {id} not found")
    return {"data": post}
```

__db.query__ is used to query the database
__(models.Post)__ is the table we are querying, we have imported the models.py file and __Post__ is one of the model in that file.
__.filter(models.Post.id == id)__ is used to filter the data we want to retrieve. We are filtering the data by the id.

***
***

### Deleting a single item with orm
```python
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int, db: Session = Depends(get_db)):
    deleted_post = db.query(models.Post).filter(models.Post.id == id)

    if deleted_post.first() == None:
        raise HTTPException(status_code=404, detail=f"Post of id {id} not found")

    deleted_post.delete(synchronize_session=False)
    db.commit()

    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

***
***

### Updating a single item with orm
```python
@app.put("/posts/{id}", status_code=status.HTTP_202_ACCEPTED)
def update_post(id: int, post: Post, db: Session = Depends(get_db)):
    required_post = db.query(models.Post).filter(models.Post.id == id)
    updated_post = required_post.first()

    if not updated_post:
        raise HTTPException(status_code=404, detail=f"Post with id {id} not found")

    required_post.update(post.dict(), synchronize_session=False)
    db.commit()

    return {"data": required_post.first()}
```

***
***

## pydantic/schema model
```python

class Post(BaseModel):
    title: str
    content: str
    published: bool = True
```

This defines the structure of the data that the user should send through the api as well as the response by the fastAPI. It is used to validate the data sent to the server and the data sent back to the user. All data should meet the requirements of the schema.

## sqlalchemy model
```python
class Post(Base):
    __tablename__ = 'posts'

    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(String(255), nullable=False)
    content = Column(String, nullable=False)
    published = Column(Boolean, server_default='TRUE', nullable=False)
    created = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))
```

This defines the structure of the data that will be stored in the database. It is used to validate the data that will be stored in the database.
It also creates the table in the database.

The two are different, while we don't need the pydantic model, it's useful since it allows us to validate the data sent to the server and the data sent back to the user and when it comes to api's, we want to be safe as possible.

### separating the schemas
```python
class CreatePost(BaseModel):
    title: str
    content: str
    published: bool = True

# we want the user while updating, to pass all the items
class UpdatePost(BaseModel):
    title: str
    content: str
    published: bool
```

#### REASON

We have the above schemas separate from the main file. To avoid clutter.
We have more that one schema above that represent similar data but for different api routes, this is because, sometimes you want the the data a user can update to be different from that of the one they can create.

IN the above snippet, the user is expected to pass all the values while updating, but when creating, the user is not expected to pass the published value, it is optional and has a default value of True.

If we wanted the user to only update on item we could:
```python
class UpdatePost(BaseModel):
    title: str
```
Here the user can only update the title alone.

### A better way to structure multiple related schemas
```python
class PostBase(BaseModel):
    title: str
    content: str
    published: bool = True

class PostCreate(PostBase):
    pass
```

This way, the __PostCreaet__ has all the atributes of PostBase using the __pass__ keyword. If we wanted to change the default value of published, we could do so in the __PostCreate__ class.

***
***

## SENDING A RESPONSE BACK

Defining a pydantic schema that will define the structure of the data that will be sent back to the user.
This is relevant because sometimes we may want to send only pieces of data back to the user and not the entire data.

Example: When a user creates an account, we don't want to send them back their password but we may want to send them their username and email.

```python
class PostResp(BaseModel):
    title: str
    content: str
    published: bool

    class Config:
        orm_mode = True
```

Now to use this:
```python
@app.post("/posts", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

When we create a new field now, the data we send back to the user only has three fields, the __timestamp__ field is not sent back to the user since we did not include it in the __PostResp__ schema.

to include the timestamp field, we can add it to the __PostResp__ schema.

```python
from datetime import datetime

class PostResp(BaseModel):
    title: str
    content: str
    published: bool
    created: datetime

    class Config:
        orm_mode = True
```

to limit duplication, you can extend any class and add the fields you want to add.
we will inherit the __PostBase__ class and add the __created__ field to it.

the __postbase__ class has the __title__, __content__ and __published__ fields.

```python
class PostBase(PostBase):
    created: datetime

    class Config:
        orm_mode = True
```

When it comes to retrieving all responses with the defined response schema:
```python

@app.get("/posts", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db)):
    my_posts = db.query(models.Post).all()
    return my_posts
```

We have to use the __list__ keyword to tell fastapi that we are returning a list of items.


# USER FUNCTIONALITY
## Creating a User
```python
class UserCreate(BaseModel):
    email: EmailStr
    password: str

class UserResp(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

@app.post("/users", status_code=status.HTTP_201_CREATED, response_model=schemas.UserResp)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    hashed_password = pwd_context.hash(user.password)
    user.password = hashed_password
    
    new_user = models.User(**user.dict())

    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user
```

***
***

### fetching user data 
```python
@app.get("/users/{id}", response_model=schemas.UserResp)
def get_user(id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == id).first()

    if not user:
        raise HTTPException(status_code=404, detail=f"User of id {id} not found")
    return user
```

## ROUTERS
They will help us to separate our routes into different files. This will help us to avoid cluttering our main file.

```main.py```
```python
app.include_router(post.router)
app.include_router(users.router)
```

```post.py```

__THE PREFIX IS OPTIONAL - WHILE I HAVE USED IT IN THE LEARNING PROCESS, I DO NOT PREFER TO USE IT IN MY PROJECTS__
```python
router = APIRouter(
    prefix="/posts",
)


@router.get("/", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db)):
    my_posts = db.query(models.Post).all()
    return my_posts


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

### STYLING THE DOCS SO THAT ALL ROUTES ARE SECTIONED ACCORDING TO THEIR ACTIONS
```users.py```
```python
router = APIRouter(
    tags=["users"]
)
```

```post.py```
```python
router = APIRouter(
    tags=["posts"]
)
```

***
# IMPORTANT SECTION
***
## AUTHENTICATION
There are two ways of authenticating users, __session__ and __token__ authentication.

## JWT TOKEN AUTHENTICATION
We will use the jwt token authentication since its stateless and we don't have to store the token in the database nor in the api server. It is stored in the client side.

#### How it's used
The user logs in with their credentials and then they are assigned a __token__ which they will use to access the protected routes. The token is sent to the server with every request in the __header__ and the server will verify the token and if it's valid, it will grant the user access to the protected routes.

In the Jwt, when sending the token to the server, be careful witht the data you pass to the __payload__, it is not encrypted and can be decoded by anyone. Don't pass sensitive data to the payload. Also do not jam alot of info in the payload, it will make the token large and it will take time to send it to the server.

### logging user
```routes/auth.py```
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from .. import schemas, database, models, utils

router = APIRouter(
    tags = ['Authentication']
)

@router.post('/login')
def login(user_credentials: schemas.UserLogin, db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()

    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Invalid credentials")

    if not utils.verify(user_credentials.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Incorrect credentials")

    

    return user
```

***
### implementing oauth2
```bash
pip install python-jose[cryptography]
```

```python
from jose import JWTError, jwt
from datetime import datetime, timedelta

# secret key
# algorithm
# expiration time

SECRET_KEY = "b7ffab7e88ff8ec8e6c258944ec6677542bd7a16431ef01c0b78aaea77b26e04"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# payload
def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

__SECRET_KEY__ run the following command to generate a secret key
__expire__ current_time + time_to_expire(30 mins)
__to_encode.update__ is a copy of the data passed to the function and we are adding the expire time to it.

```bash
openssl rand -hex 32
```

### update to login route due to OAUTH2

```python
from fastapi import APIRouter, Depends, HTTPException, status, Response
from fastapi.security.oauth2 import OAuth2PasswordRequestForm

@router.post('/login')
def login(user_credentials: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.username).first()

    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Invalid credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Incorrect credentials")

    # the data we want in the payload to be passed here (email/id/username)
    access_token = oauth2.create_access_token(data={"user_id": user.id})

    return {"access_token" : access_token, "token_type": "bearer"}
```

The oauth password request form only returns username and password,so, our email will be stored under username hence we have to adjust our code accordingly.

Now when we are testing the api route, we will no longer user the __body__  section, we will use the __form-data__ section.
We will enter the username as key and pass the email as the value. We will do the same for the password.


### verifying the token (its not tampered with and not expired)
we will start by defining a schema for the token

***
As long there is data been sent to the api or from it, we will create __schemas__ for them to ensure compliance
***

```python
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    user_id: Optional[str] = None
```

The token data is what we send to the token creation function as payload. Its optional cause you get to decide what you want to send to the payload.

```python
def verify_access_token(token: str, credentials_exception):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        _id = payload.get("user_id")

        if _id is None:
            raise credentials_exception

        token_data = schemas.TokenData(_id=user_id)
    except JWTError:
        raise credentials_exception

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(database.get_db)):
    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials", headers={"WWW-Authenticate": "Bearer"})

    return verify_access_token(token, credentials_exception)
```

__return verify_access_token(token, credentials_exception)__ returns the token_data on success and raises an error on failure.

To use it to block access to route (protecting a route to authoried users only):
```python
@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db), user_id: int = Depends(oauth2.get_current_user)):
    new_post = models.Post(**post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

we have added the dependancy to the route, now, when we try to access the route without the token, we will get an error. __get_current_user: int = Depends(oauth2.get_current_user)__

### testing
to test the route with postman, we will first login and get the token, we will then copy the token and paste it in the __Authorization__ section of the __Headers__ tab. We will then add the __Bearer__ keyword before the token.


## POSTMAN
***
### environment
you should also use environments on postman to avoid having to copy and paste the token every time you want to test the route.

i.e: DEV, PROD, TEST

### env variables/access_token
you can also use global variables to store the token and use it in the headers section.


__setting the env variable__
```python
pm.environment.set("access_token", pm.response.json().access_token)
```

__retreiving the env variable__
```python
{{access_token}}
```
***

# RELATIONSHIPS
When we are setting up a foreign key so that all the __posts__ created get to store the creator we could use our schemas __PostCreate__ schema to ensure that the id is passed but in our case, we will use the token auth to extract this, this is because the only person allowed to create a post is one who is logged in, hence we will assign the logged in account the owner status of that post.
    
```python
@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.PostResp)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user)):
    new_post = models.Post(owner_id = current_user.id, **post.dict())

    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

We will then restrict the __delete__ options and __update__ routes so that only the owner of the post can delete or update the post.

```python
@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int, db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user)):
    deleted_post = db.query(models.Post).filter(models.Post.id == id)

    if deleted_post.first() == None:
        raise HTTPException(status_code=404, detail=f"Post of id {id} not found")

    if deleted_post.first().owner_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You are not authorized to delete this post")

    deleted_post.delete(synchronize_session=False)
    db.commit()

    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

To return only the posts of the currently logged in user, we will use the __current_user__ variable to filter the posts.

```python
@router.get("/", response_model=list[schemas.PostResp])
def get_my_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user)):
    my_posts = db.query(models.Post).filter(models.Post.owner_id == current_user.id).all()
    return my_posts
```

***
say we are building a social media application, when users view another persons post, showing them their id will mean nothing to them, what users wants to see is, a username of handle of the person who created it. Since we already have a relationship between the post and the user where we store the owner_id in the post when its created, we can use that relationship to retrieve info about the owner using sqlalchemy.

```python
class Post(Base):
    __tablename__ = 'posts'

    id = Column(Integer, primary_key=True, nullable=False)
    title = Column(String(255), nullable=False)
    content = Column(String, nullable=False)
    published = Column(Boolean, server_default='TRUE', nullable=False)
    created = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))
    owner_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    owner = relationship("User")
```

We have added the owner field and the relationship reference to the user model.
To make sure  that information is sent back, we ahave to update our __postResp schema__ to include the owner field.

```python
class PostResp(PostBase):
    id: int
    created: datetime
    owner_id: int
    owner: UserResp
```

Now when there is a post response, the structure above will be used, and owner above is of type __UserResp__ which is a schema that defines the structure of the data that will be sent back to the user.

***
***

# QUERY PARAMETERS
They are used to filter data. They are passed in the url.

Query parameters will help with api pagination. We will use the __limit__ and __offset__ query parameters to achieve this.

### LIMIT

```python
@router.get("/", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user), limit: int = 10):
    my_posts = db.query(models.Post).limit(limit).all()
    return my_posts
```

here we have a limit parameter with a default value of ten, when a user does not pass a alue to the limit, the 10 posts will be displayed but when they pass a value, that value will be used.

### SKIP/OFFSET
Here a user can pass a value to the skip parameter and the number of posts skipped will be equal to the value passed.

```python
@router.get("/", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user), limit: int = 10, skip: int = 0):
    my_posts = db.query(models.Post).limit(limit).offset(skip).all()
    return my_posts
```

__pagination__
These two will come in handy on the frontend consumer, when a user moves from page one to page two, and each page shows 5 items, on page two we should be able to skip the first 5 entries.

### search
The search keyword below will return all titles that contain the value of search in them.

```python
@router.get("/", response_model=list[schemas.PostResp])
def get_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user), limit: int = 10,
              skip: int = 0, search: Optional[str] = None):
    my_posts = db.query(models.Post).filter(models.Post.title.contains(search)).limit(limit).offset(skip).all()
    return my_posts
```


### using spaces in search
When a user searches for a title with spaces, the spaces will be replaced with the __%__ sign.
```{{URL}}/posts/?search=hello%20world```


# VOTING SYSTEM
We will create a voting system where users can vote on posts. We will create a table that will store the votes and the user who voted and the post that was voted on.

one post can be liked by many users
many users can like one post
but
one user can't like a post more than once

### Composite Keys
We will use composite keys to ensure that a user can't like a post more than once. A composite key is a key that is made up of two or more columns. In our case, the composite key will be the user_id and the post_id.

i.e

say we have a table with post_id and user_id, what composite keys does, is ensure the whole row is unique, so, if a user likes a post, the row will be unique, if they like it again, the row will not be unique and the database will throw an error.
There can't be any other row that looks like the other.

unlike a primary key which only ensures that the column is unique.(one element in the column is unique)

```vote.py```
```python
from fastapi import FastAPI, Request, Response, status, APIRouter, Depends, HTTPException
from .. import models, database, schemas, oauth2
from sqlalchemy.orm import Session

router = APIRouter(
    prefix="/vote",
    tags=["Vote"],
)

@router.post("/", status_code=status.HTTP_201_CREATED)
def vote(vote: schemas.Vote, db: Session = Depends(database.get_db), current_user: int = Depends
    (oauth2.get_current_user)):

    vote_query = db.query(models.Vote).filter(models.Vote.post_id == vote.post_id, models.Vote.user_id == current_user.id)
    
    liked_post = vote_query.first()

    if (vote.direction == 1):
        if liked_post:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="You already liked this post")
        
        new_vote = models.Vote(user_id=current_user.id, post_id=vote.post_id)
        db.add(new_vote)
        db.commit()

        return {"detail": "Post liked"}
    else:
        if not liked_post:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="You haven't liked this post")
        
        vote_query.delete(synchronize_session=False)
        db.commit()

        return {"detail": "Post unliked"}
```

We are goin to extract the id of the user from the token and use it to create the vote.

We will use the __vote.direction__ to determine if the user is liking or unliking the post.

We will use the __vote_query__ to check if the user has already liked the post, if they have, we will throw an error, if they haven't, we will create the vote.

# JOINS
We will use joins to get the posts that a user has liked.

```sql
SELECT * from posts left join users on posts.owner_id = users.id;

select title, content, email from posts left join users on posts.owner_id = users.id;
```
__Explanation__:
We are selecting all the columns from the posts table and we are joining the users table on the posts.owner_id and users.id columns.

We are selecting the data from both tables and displaying it as one, we are using the common denominator being the __owner_id__ and __id__ columns.

the owner_id is a foreign key that references the id of the users table, so, if they __owner_id__ in the posts table matches the __id__ in the users table then we will display the data from both tables.

__We can use the joins to count the number of likes/vote each post have, we will need a __join, group by and count__ to achieve this.__

```sql
select posts.id, title, content, email, count(votes.id) from posts left join users on posts.owner_id = users.id left join votes on posts.id = votes.post_id group by posts.id, users.id;
```

### counting in the route
```python
@router.get("/")
def get_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user), limit: int = 10,
              skip: int = 0, search: Optional[str] = None):
    my_posts = db.query(models.Post).filter(models.Post.title.contains(search)).limit(limit).offset(skip).all()
    
    num_likes = db.query(models.Post, func.count(models.Vote.post_id).label("votes")).join(models.Vote, models.Vote.post_id == models.Post.id, isouter=True).group_by(
        models.Post.id).all()

    return num_likes
```

Now the votes will be returned with the posts.



# migrations with alembic
```bash
pip install alembic

alembic init migrations
alembic --help

alembic revision -m "create posts table"
alembic upgrade 6dc49806a1ba
alembic upgrade head

alembic revision -m "create votes table"
alembic upgrade head # to upgrade to the latest migration

alembic downgrade -1 # to undo the last migration
alembic upgrade +2 # to upgrade to the next migration

# use this two lines to generate the tables automatically - stress free
alembic init migrations
alembic revision --autogenerate -m "all tables" # to create a migration file for all the tables
alembic upgrade head # to upgrade to the latest migration
```

# CORS
Cross Origin Resource Sharing

search for __CORS__ in the fastAPI documentation
```python
from fastapi.middleware.cors import CORSMiddleware

origins = []

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)
```

__allow_origins__ specifies the domain that are allowed to communicate to our api

__allow_credentials__ specifies if the api should allow credentials to be passed to it.

__allow_methods__ specifies the methods that are allowed to be used to communicate with our api. If yu have a public api, you may want to only allow users to get information from the apoi but not send to it, if this is the case, you only allow the __get__ method.

__allow_headers__ specifies the headers that are allowed to be passed to the api.

__For public api's, the origins can have a wild card __*__ to allow all domains to communicate with the api. But if the api is private, you can specify the domains that are allowed to communicate with the api.__

__if the api is built for a cetain application, you want to configure the origins to only allow that application to communicate with the api only. any other origin will be blocked.__

# DEPLOYING THE API
I will check out the heroku deployment then deploy to render.




**IMPORTANT**
We never run alembic revisions on the production server, we only do that on the development server when we are staging the changes. 
__On production we only push our code to github together with the revision contained in the alembic/revisions folder__
__After pushing everything to github, we run the alembic upgrade head in the production server__

***
check out how you can run the commands in our render server or how to migrate your revisions on your cloud server hosting the postgres database you are using.
***

# DOCKERIZING OUR API
We will also set up a postgres database in a docker container and connect to it from our api.

```hub.docker.com```
We are going to search for an offcial python image and use it to build our docker image. (choose one you built your api with)

This images are standard images, they only have the python installed, this means that we are going to have to copy all our files to the docker image and install all the dependencies.

To avoid that, we could write our wn image that will have all the dependencies we need.
We are going to write our dockerfile and you can follow the example provided on the python docs on docker.hub


```Dockerfile```
```docker
FROM python:3.10.12

WORKDIR /usr/src/app

COPY requirements.txt ./

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000" ]
```

__WORKDIR__ is the directory where the application will live and this step is optional, but you get to choose where you want your application to live.

## BUILDING THE IMAGE
The docker file is complete, now we build the image.

if not root user, use sudo
```bash
docker build -t fastapi .

docker image ls

```

__Now we can use the image built above to build a container__


### docker compose | CONTAINERS
Building a container invlolves running commands like __docker run__ and others but we can avoid doing all that by using docker compose, we write out our commands in a file and run them all at once.

You start by soecifying the version of docker compose you are using, then you specify the services you want to run, in our case, we want to run the api and the database.

```docker-compose.yml```
```yml
version: "3"
services:
  api:
    build: .
    ports:
      - "8000:8000"
```

```bash
docker-compose up -d
```

run:
```bash
docker ps
```
This commands tells you the containers that are running or crashed. Check the status column.
If ti requires the env variables

```yml
version: "3"
services:
  api:
    build: .
    ports:
      - "8000:8000"
    # env_file:
    #   - .env
    environment:
      - DB_HOST=127.0.0.1
      - DB_NAME=fastapi
      - DB_USER=postgres
      - DB_PASSWORD=mankindjnr
      - DB_PORT=5432
      - SECRET_KEY = "b7ffab7e88ff8ec8e6c258944ec6677542bd7a16431ef01c0b78aaea77b26e04"
      - ALGORITHM = "HS256"
      - ACCESS_TOKEN_EXPIRE_MINUTES = 60

```
We will tear down our current container and rebuild
```bash
docker-compose down
docker-compose up -d
```

This time around, it did not build an image, it used the image we had built earlier.
But, if you made changes to the dockerfile, you can force it to build an image by adding the flag __--build__

```bash
docker-compose up -d --build
```

You can test if the container is up by running the following in postman or in the browser
```
localhost:8000
```
Whatever the response of the base route is, is what you will get.

### DATABASE SETUP IN A CONTAINER
spinning up an image of postgres
__even when you are not dockerizing your image its good to use a container for your database__

Foe this we will use the official postgres image found on docker hub.

```docker-compose.yml```
```yml
version: "3"
services:
  api:
    build: .
    ports:
      - "8000:8000"
    # env_file:
    #   - .env
    environment:
      - DB_HOST=postgres
      - DB_NAME=fastapi
      - DB_USER=postgres
      - DB_PASSWORD=mankindjnr
      - DB_PORT=5432
      - SECRET_KEY="b7ffab7e88ff8ec8e6c258944ec6677542bd7a16431ef01c0b78aaea77b26e04"
      - ALGORITHM="HS256"
      - ACCESS_TOKEN_EXPIRE_MINUTES=60

  postgres:
    image: postgres
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=mankindjnr
      - POSTGRES_DB=fastapi
    
    volumes:
      - postgres_data:/var/lib/postgresql/data/

volumes:
  postgres_data:
```

__postgres__ is another service we are running, we are using the official postgres image and we are specifying the environment variables we want to use.

__volumes__ they are used to persist data, if we don't use volumes, when we tear down the container, the data will be lost. We are using volumes to store the data in the postgres_data folder.

We changed the db host from __127.0.0.1__ to __postgres__ since we are using a container for the database. It will then reference the postgres service we have created.

```bash
docker exec -it api-development_api_1 bash
```


# REPOSITORY FOR IMAGES
We will use docker hub to store our images.

create an account on docker hub and create a repository.

With a repo, i could now push my image:
To see the images  have built:
```bash
docker image ls
```

To push:
login to docker hub
```bash
docker login
```

```bash
sudo docker image tag api-development_api mankindjnr/apidev
docker push mankindjnr/apidev
```